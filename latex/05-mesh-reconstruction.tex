\newpage
\setcounter{figure}{0}

\section{Izgradnja 3D modela scene} % (fold)
\label{sec:Izgradnja 3D modela scene}

\subsection{Snimanje scene 3D kamerom i RGBDSlam programom} % (fold)
\label{sub:Snimanje scene 3D kamerom i RGBDSlam programom}
Program RGBDSlam razvijen je suradnjom
Albert-Ludwigs-Unversität\footnotemark[6] sveučilišta u Freiburgu i
Technische Universität München\footnotemark[7] sveučilišta u Münchenu.
Slobodan je program objavljen pod GPLv3 licencom.

\footnotetext[6]{%
\href{http://www.informatik.uni-freiburg.de/~endres/}%
{Felix Endres} i \href{http://www.informatik.uni-freiburg.de/~hess/}%
{Juergen Hess} sa odijela \href{http://ais.informatik.uni-freiburg.de/}%
{Autonomous Intelligent Systems} koji vodi
\href{http://www.informatik.uni-freiburg.de/~burgard/}%
{Prof. Dr. Wolfram Burgard}.
}
\footnotetext[7]{%
\href{http://vision.in.tum.de/members/engelhan}%
{Nikolas Engelhard} sa odijela \href{http://vision.in.tum.de/}%
{Computer Vision Group} koji vodi
\href{http://vision.in.tum.de/members/sturmju}% 
{Dr. Juergen Sturm}.
}

% subsection Snimanje scene 3D kamerom i RGBDSlam programom (end)

\newpage
\subsection{Izgradnja 3D modela scene pomoću mreže trokuta} % (fold)
\label{sub:Izgradnja 3D modela scene pomoću mreže trokuta}

Izgradnja 3D modela scene pomoću mreže trokuta je implementirana u
programu nazvanom \texttt{mesh-reconstruction}.\footnotemark[1]
Program se intenzivno oslanja na biblioteku PointCloud koja je opisana u
potpoglavlju \ref{sub:Biblioteka Pointcloud} Kao što je vidljivo iz
grafikona \ref{fig:flowchart} program je podijeljen u pet osnovnih
funkcija:
\begin{itemize}
    \item Učitavanje oblaka točaka snimljenih RGBDSlam programom.
    \item Reduciranje oblaka točaka.
    \item Uklanjanje pogrešaka pri mjerenju.
    \item Izrađivanje i zapisivanje mreže trokuta.
    \item Prikaz mreže trokuta.
\end{itemize}

\footnotetext[1]{%
Program \texttt{mesh-reconstruction} je slobodan program dostupan pod
uvijetima MIT licence. Izvorni kod se nalazi na DVD-u te na web stranici
\href{http://github.com/msvalina/}%
{github.com/msvalina/}}

\begin{figure}[h]
\renewcommand{\figurename}{Grafikon}
\centering
\includegraphics[scale=0.5]{figures/flowchart.pdf}
\caption{Dijagram toka programa \texttt{mesh-reconstruction} }
\label{fig:flowchart}
\end{figure}

U sljedećim potpoglavljima dan je pregled funkcija i PCL klasa nad kojim
se baziraju. Također na slici~\ref{fig:running-mesh-reconstruction} se
vidi kako izgleda pokretanje programa, što sve ispisuje na standardni
izlaz te kako prikazuje mrežu trokuta.

\newpage
% Reset counter becouse Grafikon and figures should have diff counters
\setcounter{figure}{0}
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{figures/running-mesh-reconstruction.png}
\caption{Prikaz pokretanja programa \texttt{mesh-reconstruction} iz
terminala}
\label{fig:running-mesh-reconstruction}
\end{figure}

\subsubsection{Pregled \texttt{main()} funkcije} % (fold)
\label{ssub:Pregled main funkcije}
\begin{lstlisting}[label=lstMain,caption={Izvorni kod
\texttt{main() funkcije} }]
int main (int argc, char *argv[])
{
    downsample (argc, argv);
    remove_outliers (argc, argv);
    pcl::PolygonMesh mesh_of_triangles;
    reconstruct_mesh (argc, argv, mesh_of_triangles);
    show_mesh (mesh_of_triangles);
    return 0;
}
\end{lstlisting}
Kao što se vidi iz ispisa koda~\ref{lstMain} ideja je da funkcija bude
što manja te da se iz nje samo pozivaju druge funkcije. 

% subsubsection Pregled tt (end)

\newpage
\subsubsection{Učitavanje oblaka točaka} % (fold)
\label{ssub:Učitavanje oblaka točaka}
Program učitava podatke na početku svake funkcije, te ih zapisuje na
izlazu iz funkcije kako bih prije i poslije svake operacije bio dostupan
oblak točaka. Za to koristi \texttt{PCDReader} i \texttt{PCDWriter} klase.
Primjer takvog koda se nalazi u ispisu koda~\ref{lstUcitavanjeOblaka}

\begin{lstlisting}[label=lstUcitavanjeOblaka, caption={Primjer izvornog
koda za učitavanje oblaka točaka}]
    // Init cloud variables 
    pcl::PCLPointCloud2::Ptr cloud (new pcl::PCLPointCloud2());
    pcl::PCLPointCloud2::Ptr cloud_filtered (new pcl::PCLPointCloud2());

    // Fill in the cloud data
    pcl::PCDReader reader;
    reader.read ("pointcloud.pcd", *cloud);
    /* 
     * Do something with cloud
     */
    // Write cloud to a file
    pcl::PCDWriter writer;
    writer.write ("pointcloud-downsampled.pcd",
            *cloud_filtered, Eigen::Vector4f::Zero(),
            Eigen::Quaternionf::Identity(), false);
\end{lstlisting}

% subsubsection Učitavanje oblaka točaka (end)

\subsubsection{Reduciranje oblaka točaka} % (fold)
\label{ssub:Reduciranje oblaka točaka}
Reduciranje obalaka ne unosi gubitak informacija, a izvodi se zbog lakše
daljnje obrade oblaka. Izvodi se pomoću \texttt{VoxelGrid} klase i
implementirano je u \texttt{downsample()} funkciji. Dijelovi funkcije
prikazani su u ispisu koda~\ref{lstReduciranje}
\texttt{VoxelGrid} dolazi od riječi \textit{volume pixel grid} i
predstavlja niz malih kocaka u prostoru.

\begin{lstlisting}[label=lstReduciranje, caption={Dio izvornog koda za
reduciranje točaka iz funkcije \texttt{downsample()} }]
    // Create the filtering object
    pcl::VoxelGrid<pcl::PCLPointCloud2> vg;
    vg.setInputCloud (cloud);
    // voxel size to be 1cm^3
    vg.setLeafSize (0.01f, 0.01f, 0.01f);
    vg.filter (*cloud_filtered);
\end{lstlisting}

Kao što se vidi iz ispisa koda~\ref{lstReduciranje} nakon kreiranja
objekta \texttt{vg} predaje mu se oblak točaka nad kojim se vrši
reduciranje. Postavlja se veličina kocke (\textit{voxel}) u našem
slučaju to je 3cm\textsuperscript{3}. Nad tim oblakom prilikom
filtriranja će se kreirati mreža kocaka te će se sve točke unutar jedne
kocke zamjeniti centralnom točkom. Tim postupkom značajno se smanjuje
broj točaka u oblaku kao što je vidljivo iz
slike~\ref{fig:tablescene-downsample}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{figures/tablescene-downsampling-example.png}
% If there is \footnote in caption brackets [] must be used
\caption[description for List of Figures]{%
    Oblak točaka \textit{table\_scene}\footnotemark[2] prije i poslije %
    \texttt{downsample()} funkcije}
\label{fig:tablescene-downsample}
\end{figure}

\footnotetext[2]{Oblak točaka \texttt{table\_scene\_lms400.pcd} je
objavljen pod uvijetima BSD licence - 
\href{https://github.com/PointCloudLibrary/data/blob/master/tutorials%
/table\_scene\_lms400.pcd}{izvor}}

% subsubsection Reduciranje oblaka točaka (end)

\subsubsection{Uklanjanje pogrešaka pri mjerenju} % (fold)
\label{ssub:Uklanjanje pogrešaka pri mjerenju}
Šum pri mjerenju je sastavni dio svakog mjernog uređaja pa tako i
Kineckt kamere. PointCloud biblioteka ima ugrađenu
\texttt{StatisticalOutlierRemoval} klasu koja uklanja šum te je
implementirana u funkciji \texttt{remove\_outlieres()}.
Iz ispisa koda~\ref{lstUklanjanje} se vidi kako se klasa koristi.

% minipage ensures that listing won't be split between pages
% but it seams like it's pushing whole box slightly to the right
% \begin{minipage}{\textwidth}
\begin{lstlisting}[label=lstUklanjanje, caption={Dio izvornog koda 
iz funkcije \texttt{remove\_outliers()} }]
    // Create the filtering object
    pcl::StatisticalOutlierRemoval<pcl::PCLPointCloud2> sor;
    sor.setInputCloud (cloud);
    // Set number of neighbors to analyze
    sor.setMeanK (50);
    sor.setStddevMulThresh (1.0);
    sor.filter (*cloud_filtered);
\end{lstlisting}
% \end{minipage}

Nakon kreiranja objekta \texttt{sor} i predavanja oblaka postavljena su
još dva parametra. Prvi \texttt{setMeanK} je broj susjednih točaka koje
će filter analizirat. Drugi \texttt{setStddevMulThresh} pak kaže da će
sve točke u okolini ispitane točke čije su udaljenosti veće od jedne
standardne devijacije očekivane udaljenosti biti označne kao šum
(\textit{outlier}) i odbačene. Rezultati rada funkcije se vide na
slici~\ref{fig:tablescene-outliers}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{figures/tablescene-remove-outliers-example.png}
\caption{Oblak točaka: lijevo poslije \texttt{downsample()} i desno poslije
\texttt{remove\_outliers()} }
\label{fig:tablescene-outliers}
\end{figure}

% subsubsection Uklanjanje pogrešaka pri mjerenju (end)

\newpage
\subsubsection{Izrađivanje i zapisivanje mreže trokuta} % (fold)
\label{ssub:Izradivanje i zapisivanje mreže trokuta}

Nakon pripreme oblaka točaka funkcijama \texttt{downsample()} i
\texttt{remove\_outliers()} slijedi izrađivanje mreže trokuta unutar
funkcije \texttt{mesh\_reconstruction()}. Izrađivanje mreže trokuta se
može podijeliti u tri koraka. Prvi je estimiranje normala nad oblakom
točaka. Drugi je spajanje estimiranih normala i oblaka točaka u
zajedniči oblak točaka s normalama. Treći korak je pozivanje algoritma
za izrađivanje mreže nad novo stvorenim oblakom.

\begin{lstlisting}[label=lstIzradivanje1, caption={Dio izvornog koda iz
funkcije \texttt{reconstruct\_mesh()} }]
    // Normal estimation
    pcl::NormalEstimation<PointType, Normal> normEst;
    pcl::PointCloud<Normal>::Ptr normals (new pcl::PointCloud<Normal>);
    
    // Create kdtree representation of cloud, 
    // and pass it to the normal estimation object. 
    pcl::search::KdTree<PointType>::Ptr tree (new
            pcl::search::KdTree<PointType>);
    tree->setInputCloud (cloud);
    normEst.setInputCloud (cloud);
    normEst.setSearchMethod (tree);
    // Use 20 neighbor points for estimating normal
    normEst.setKSearch (20);
    normEst.compute (*normals);
\end{lstlisting}

Iz ispisa koda~\ref{lstIzradivanje1} se vidi da je prije estimiranja
normala nad oblakom točaka potrebno je inicijalizirati objekt za
spremanje normala i za estimaciju. Nakon toga definira se
stablo za pretraživanje oblaka tipa \texttt{KdTree}.\footnotemark[3]
Stablu se tada predaje oblak za pretraživanje. Objektu za
estimaciju \texttt{normEst} tada se predaje oblak i stablo te broj
susjednih točaka nad kojima se vrši estimacija
normala\footnotemark[4]. 

\footnotetext[3]{%
K dimenzionalno stablo je detaljno objašnjeno na stranici \href{http://%
pointclouds.org/documentation/tutorials/kdtree\_search.php}%
{pointclouds.org/documentation}}
\footnotetext[4]{%
Estimacija normala detaljno je objašnjena na stranici \href{http://%
pointclouds.org/documentation/tutorials/normal\_estimation.php}%
{pointclouds.org/documentation}}

Nakon estimacije normala slijedi spajanje estimiranih normala i oblaka u
novi oblak točaka s normalama. Kao što je prikazano u ispisu
koda~\ref{lstIzradivanje2} Taj oblak točaka je prikazan na 
slici~\ref{fig:tablescene-normals}

\newpage
\begin{lstlisting}[label=lstIzradivanje2,caption={Dio izvornog koda iz
funkcije \texttt{reconstruct\_mesh()} }]
    // Concatenate the XYZ and normal fields
    pcl::PointCloud<PointTypeN>::Ptr cloud_with_normals (new
            pcl::PointCloud<PointTypeN>);
    pcl::concatenateFields (*cloud, *normals, *cloud_with_normals);
    // cloud_with_normals = cloud + normals

    // Create search tree 
    pcl::search::KdTree<PointTypeN>::Ptr tree2 (new
            pcl::search::KdTree<PointTypeN>);
    tree2->setInputCloud (cloud_with_normals);

    // Initialize objects 
    // psn - for surface reconstruction algorithm
    // triangles - for storage of reconstructed triangles
    pcl::Poisson<PointTypeN> psn;
    pcl::PolygonMesh triangles;

    psn.setInputCloud(cloud_with_normals);
    psn.setSearchMethod(tree2);
    psn.reconstruct (triangles);
    psn.setOutputPolygons(false);
\end{lstlisting}

Nad stvorenim oblakom s normalama stvara se stablo za pretraživanje.
Zatim se inicijaliziraju objekti \texttt{psn} i \texttt{triangles}.
\texttt{psn} predstavlja \texttt{Poisson}\footnotemark[5] algoritam za
izrađivanje mreže trokuta. \texttt{triangles} je objekt tipa
\texttt{PolygonMesh} za spremanje izražunatih koordinata trokuta.
Algoritmu se sada predaje ulazni oblak, stablo pretraživanja i poziva se
rekonstrukcija.

\footnotetext[5]{%
Poisson algoritam su razvili Michael Kazhdan i Matthew Bolitho,
objavljen je pod BSD licencom. \href{http://www.cs.jhu.edu/~misha/Code/%
PoissonRecon/Version5.5/}{Službena stranica.}}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{figures/tablescene-normals.png}
\caption{Prikaz oblaka točaka \texttt{tablescene} s estimiranim
normalama }
\label{fig:tablescene-normals}
\end{figure}

Ispis koda~\ref{lstIzradivanje3} prikazuje korištenje klase
\texttt{saveVTKFile} za spremanje objekta \texttt{triangles} u datoteku
s vtk ekstenzijom.

\begin{lstlisting}[label=lstIzradivanje3,caption={Dio izvornog koda iz
funkcije \texttt{reconstruct\_mesh()} }]
    // Write reconstructed mesh
    if (argc < 2){
        pcl::io::saveVTKFile
            ("pointcloud-downsampled-outliers-mesh.vtk",
             triangles);
    }
    else {
        std::string str;
        str.append(argv[1]).append("-mesh.vtk");
        pcl::io::saveVTKFile (str, triangles);
    }
\end{lstlisting}

% subsubsection Izrađivanje i zapisivanje mreže trokuta (end)

\subsubsection{Prikazivanje mreže trokuta} % (fold)
\label{ssub:Prikazivanje mreže trokuta}
Prikazivanje mreže trokuta omogućava \texttt{PCLVisualizer} klasa. Ista
klasa se koristi u komandono linijskom programu za prikaza oblaka točaka
\texttt{pcl\_vieweru}. U ispisu koda~\ref{lstPrikaz} se vidi
jednostavnost upotrebe klase. Nakon kreiranja objekta \texttt{viewer} i
postavljanja parametara poziva se beskonačna petlja unutar koje se
pokrene prozor s prikazom mreže trokuta. Klikom na tipku \texttt{q}
izlazi se iz petlje i program završava.
Slika~\ref{fig:tablesecne-mesh-perspectives} prikazuje izgled mreže iz
četiri pogleda.

\begin{figure}[h]
\centering
\includegraphics[scale=0.25]{figures/tablescene-mesh-perspectives.png}
\caption{Prikaz mreže trokuta funkcijom \texttt{show\_mesh()} }
\label{fig:tablesecne-mesh-perspectives}
\end{figure}

\newpage
\begin{lstlisting}[label=lstPrikaz,caption={Izvorni kod funkcije
\texttt{show\_mesh()} }]
void show_mesh (const pcl::PolygonMesh& mesh_of_triangles)
{
    std::cout << "Started - show_mesh() with PCLVisualizer\n";
    // Create viewer object and show mesh
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new
          pcl::visualization::PCLVisualizer ("3D Viewer"));
    viewer->setBackgroundColor (0, 0, 0);
    viewer->addPolygonMesh (mesh_of_triangles, "sample mesh");
    viewer->initCameraParameters (); 
    while (!viewer->wasStopped ())
    {
        viewer->spinOnce (100); boost::this_thread::sleep
            (boost::posix_time::microseconds (100000));
    }
    std::cout << "Finshed - show_mesh() with PCLVisualizer\n";
}
\end{lstlisting}


% subsubsection Prikazivanje mreže trokuta (end)

% subsection Izgradnja 3D modela scene pomoću mreže trokuta (end)

% section Izgradnja 3D modela scene (end)
